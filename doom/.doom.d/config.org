#+TITLE: config

* general config
** ui
*** theme

#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-nord)
#+END_SRC
*** curser theme

#+BEGIN_SRC emacs-lisp
(set-cursor-color "#ffb6c1")
#+END_SRC

*** paren-mode
Highlight matching parentheses and such in every mode.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
*** line number

Show line numbers to the left for better jumping.
(consider the ace jump package which shows a letter for every line for more efficient jumping)

#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
#+END_SRC

*** line truncation

stupid doom tries to truncate lines all the time which I don't like. This means
that long lines go past the window end. When this is turned off they appear
soft wrapped.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines nil)
#+END_SRC

*** pretty symbols

Emacs ships default with =prettify-symbols mode=.

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode 1)
#+END_SRC
doesn't seem to do anything in doom
*** hl-line

Highlighting the current line is all nice and stuff but it looks off in org mode due to different sizes of headings.
Similarly in LaTeX due to sub/super -scripts.

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'hl-line-mode)
#+END_SRC

doesn't work...
*** opacity

Make emacs opaque (when running compton).

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(90 . 90))
(add-to-list 'default-frame-alist '(alpha . (90 . 90)))
#+END_SRC
** general behavior

When splitting windows, put split on a reasonable side.

#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC


** email

currently still using mutt. This tells Emacs to use mail mode when editing emails through mutt.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/mutt" . mail-mode))
(add-to-list 'auto-mode-alist '("/neomutt" . mail-mode))
#+END_SRC

This is copied from [[https://github.com/NicolasPetton/emacs.d/blob/3945786c31a17ac9caa8894109c231234956102f/hosts/blueberry/init-notmuch.el][github]] who took it from [[http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html][this blog]].

#+BEGIN_SRC emacs-lisp
;; Function to return first name of email recipient
;; Used by yasnippet
#+END_SRC

** dashboard

Show agenda for upcoming week and not just today.

#+BEGIN_SRC emacs-lisp
(setq show-week-agenda-p t)
#+END_SRC

** GTD

Keep everything out of your head, aka building a second brain.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-references ()
  "go to my references file"
  (interactive)
  (find-file "~/org/Reference.org"))
#+END_SRC

** general nifty mappings

Most of the time I only have two windows open. Switching between should be easy.

#+BEGIN_SRC emacs-lisp
(map! "M-w" 'other-window)
#+END_SRC
* config file

** quick access

Configuring never stops. keep the config file close.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-emacs-config ()
  "go to emacs config file"
  (interactive)
  (find-file "~/.doom.d/config.org"))

(map! :leader "e c" #'ab/visit-emacs-config)
#+END_SRC

** reload
When regularly changing configs we also want to be able to use them without restarting emacs.

#+BEGIN_SRC emacs-lisp
(defun ab/reload-init-file ()
  "reload config file"
  (interactive)
  (load-file "~/.doom.d/config.el"))

(map! :leader "e r" 'ab/reload-init-file)
#+END_SRC

* vi
** config

not quite sure what this does but it seems to fix some weird behavior with
visual lines

#+BEGIN_SRC emacs-lisp
(setq evil-respect-visual-line-mode nil)
#+END_SRC

** leader

More vim functionality.

Set the leader key and some very basic keybindings.

#+BEGIN_SRC emacs-lisp
(map! :leader
      "b" #'switch-to-buffer
      "q" #'kill-buffer
      "s h" #'evil-window-split
      "s v" #'evil-window-vsplit
      "e c" #'ab/visit-emacs-config
      "r" #'ab/visit-references
      "n" #'other-window
      "w" #'save-buffer)
#+END_SRC


Quickly open shell in a split.

#+BEGIN_SRC emacs-lisp
(defun ab/open-shell-in-split ()
  ;; open eshell
  (interactive)
  ;; (evil-window-split)
  (eshell))

(map! :leader "s s" 'ab/open-shell-in-split)
#+END_SRC
** colemak settings

Evil for colemak keyboard layout. Adapted from the [[https://github.com/wbolster/evil-colemak-basics][evil-colemak-basics]] package. For some reason trying to defining everything manually via ~evil-define-key~ or ~define-key evil-motion-state-map~ gave me trouble with ~'inner-text-objects~ and more..

#+BEGIN_SRC emacs-lisp
(defgroup evil-colemak nil
  "Basic key rebindings for evil-mode with the Colemak keyboard layout."
  :prefix "evil-colemak-"
  :group 'evil)

(defcustom evil-colemak-char-jump-commands nil
  "The set of commands to use for jumping to characters.
        By default, the built-in evil commands evil-find-char (and
        variations) are used"
  :group 'evil-colemak
  :type '(choice (const :tag "default" nil)))

(defun evil-colemak--make-keymap ()
  "Initialise the keymap baset on the current configuration."
  (let ((keymap (make-sparse-keymap)))
    (evil-define-key '(motion normal visual) keymap
      "n" 'evil-next-line
      "gn" 'evil-next-visual-line
      "gN" 'evil-next-visual-line
      "e" 'evil-previous-line
      "ge" 'evil-previous-visual-line
      "E" 'evil-lookup
      "i" 'evil-forward-char
      "I" 'evil-end-of-line
      "j" 'evil-forward-word-end
      "J" 'evil-forward-WORD-end
      "gj" 'evil-backward-word-end
      "gJ" 'evil-backward-WORD-end
      "k" 'evil-ex-search-next       ;; doom needs an "ex"
      "K" 'evil-ex-search-previous   ;; doom needs an "ex"
      "gk" 'evil-next-match
      "gK" 'evil-previous-match
      "zi" 'evil-scroll-column-right
      "zI" 'evil-scroll-right)
    (evil-define-key '(normal visual) keymap
      "N" 'evil-join
      "gN" 'evil-join-whitespace)
    (evil-define-key 'normal keymap
      "l" 'evil-insert
      "L" 'evil-insert-line)
    (evil-define-key 'visual keymap
      "L" 'evil-insert)
    (evil-define-key '(visual operator) keymap
      "l" evil-inner-text-objects-map)
    (evil-define-key 'operator keymap
      "i" 'evil-forward-char)
    keymap))
;; ~I~ is still available

(defvar evil-colemak-keymap
  (evil-colemak--make-keymap)
  "Keymap for evil-colemak-mode.")

(defun evil-colemak-refresh-keymap ()
  "Refresh the keymap using the current configuration."
  (setq evil-colemak-keymap (evil-colemak--make-keymap)))

      ;;;###autoload
(define-minor-mode evil-colemak-mode
  "Minor mode with evil-mode enhancements for the Colemak keyboard layout."
  :keymap evil-colemak-keymap
  :lighter " hnei")

      ;;;###autoload
(define-globalized-minor-mode global-evil-colemak-mode
  evil-colemak-mode
  (lambda () (evil-colemak-mode t))
  "Global minor mode with evil-mode enhancements for the Colemak keyboard layout.")

(after! evil
  (global-evil-colemak-mode))

;; (map! "I" 'evil-org-end-of-line)
;; (map! "H" 'evil-first-non-blank)
#+END_SRC

Switching windows also relies on the `hjkl` motions. So make it colemak friendly.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil-maps
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "e" 'evil-window-up)
  (define-key evil-window-map "i" 'evil-window-right))
#+END_SRC

** matchit

Extend the ~%~ functionality to jump between tags such as LaTeX ~\begin{...}~ and ~\end{...}~. This is sooo important!!!

#+BEGIN_SRC emacs-lisp
(after! evil
  (use-package! evil-matchit
    :config
    (global-evil-matchit-mode)))
#+END_SRC

** paragraph

The function ~evil-forward-paragraph~ (default bound to ~}~) reuses Emacs'
~forward-paragraph~ which is different in every major mode. I've gotten used to
vim's behaviour of just going to the next empty line. This chunk makes evil use
the default paragraph. This makes so much more sense considering commands like
~y a p~ (read "yank around paragraph") treats paragraphs always the the way I
want them. Got this from [[https://emacs.stackexchange.com/questions/38596/make-evil-paragraphs-behave-like-vim-paragraphs][here]].

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (defadvice forward-evil-paragraph (around default-values activate)
    (let ((paragraph-start (default-value 'paragraph-start))
          (paragraph-separate (default-value 'paragraph-separate)))
      ad-do-it)))
#+END_SRC
** custom

#+BEGIN_SRC emacs-lisp
(map! :n "H" #'evil-first-non-blank)
(map! :n "I" #'evil-end-of-line)
(map! :n "E" #'+lookup/definition)
#+END_SRC

* buffer handling

Switch back and forth between the two MRU buffers.

#+BEGIN_SRC emacs-lisp
(defun ab/switch-to-previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(map! :leader "SPC" #'ab/switch-to-previous-buffer)
#+END_SRC

* org mode

#+begin_center
=Your life in plain text=
#+end_center

** config

Load orgmode plus some standard keybindings.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-hide-emphasis-markers nil
        org-return-follows-link t
        org-tags-column 0                   ;; position of tags
        org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)")
                            (sequence "TODO(t)" "DIDN'T SUCCEED(s)" "|" "DOESN'T WORK(x)"
                                      "TOO HARD(h)" "DONE(d)"))
        org-todo-keyword-faces '(("WAITING" :foreground "#8FBCBB" :weight bold))))

(map! :leader
      "o s l" 'org-store-link
      "o a" 'org-agenda
      "o c" 'org-capture)
#+END_SRC

Line numbers in org mode are useless

#+BEGIN_SRC emacs-lisp
(defun ab/disable-line-numbers ()
  (interactive)
  (display-line-numbers-mode -1))

(add-hook 'org-mode-hook #'ab/disable-line-numbers)
#+END_SRC

** structure and files

Tell emacs where I store my org stuff.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-directory "~/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  ;; (setq org-inbox-file "~/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s")))
#+END_SRC

This sets the file from which the agenda is derived. All my todos are in the index file.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-files (list org-index-file
                               (org-file-path "Reference.org"))))
#+END_SRC

By default org-mode does super ugly truncation of long lines (apparently because of tables). I want line wrapping, however.

#+BEGIN_SRC emacs-lisp
(after! org (setq org-startup-truncated 'nil))
#+END_SRC

By default org-agenda only shows one week starting last monday. I want two weeks starting today.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-start-day "-0d"))
#+END_SRC
** export

#+BEGIN_SRC emacs-lisp
;; (after! org
;;   (setq org-export-use-babel t)
;;   (map! :map org-mode-map
;;         :leader
;;         (:prefix "e"
;;           (:prefix ("p" . "latex")
;;             :desc "to latex"            "l" #'org-pandoc-export-to-latex
;;             :desc "to latex & open"     "L" #'org-pandoc-export-to-latex-and-open
;;             :desc "to latex pdf"        "p" #'org-pandoc-export-to-latex-pdf
;;             :desc "to latex pdf & open" "P" #'org-pandoc-export-to-latex-pdf-and-open))
;;         (:prefix ("o" . "src")
;;           :desc "previous block"        "p" #'org-babel-previous-src-block
;;           :desc "next block"            "n" #'org-babel-next-src-block
;;           :desc "execute block"         "e" #'org-babel-execute-src-block)))
#+END_SRC

** keybindings
*** structure editing

Org structure editing made easy/mnemonic with leader.

#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        :leader
        "o t" 'org-toggle-heading      ;; toogle wheter heading or not
        "o w" 'widen                   ;; show everythig
        "o n" 'org-narrow-to-subtree)  ;; show only what's within heading
)
#+END_SRC

~org-narrow-subtree~ shows only a single heading (the heading of the current subtree). I need more context!! I want the to see which hierarchy this heading belongs to. taken from [[https://emacs.stackexchange.com/questions/29304/how-to-show-all-contents-of-current-subtree-and-fold-all-the-other-subtrees][stackexchange]].
But this also shows all heading of level 1 and all headings of the same level as current heading

#+BEGIN_SRC emacs-lisp
(defun ab/org-show-just-me (&rest _)
  "Fold all other trees, then show entire current subtree."
  (interactive)
  (org-overview)
  (org-reveal)
  (org-show-subtree))

(map! :map org-mode-map
      :leader "o r" 'ab/org-show-just-me)            ;; Mnemonic: restrict
#+END_SRC

Use vim instead of arrows.
#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
      "M-e" #'org-metaup
      "M-i" #'org-metaright
      "M-n" #'org-metadown)
#+END_SRC

Use ~o~ instead of ~RET~ for new headings/list-items.
#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
      "M-o" '+org/insert-item-below
      "M-S-o" '+org/insert-item-above)
#+END_SRC

*** index file

Quickly access the org index file.

#+BEGIN_SRC emacs-lisp
(defun ab/open-index-file ()
  "Open the master org TODO list."
  (interactive)
  (find-file org-index-file)
  (end-of-buffer))

(map! :leader "i" #'ab/open-index-file)
#+END_SRC

*** navigation

Mnemonic navigation.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
        :leader
        "g h" 'org-previous-visible-heading      ;; Go Heading of current section
        "g e" 'org-previous-visible-heading      ;; Go e (= colemak up)
        "g u" 'outline-up-heading                ;; Go Up in hierarchy
        "g n" 'org-next-visible-heading          ;; Go Next heading
        )
#+END_SRC

The above motions are easy to remember but feel clunky when trying to go more then one heading up or down (this is probably an antipattern anyways..). Either way, here are some single key mappings.
I don't use ~(~ or ~)~ in evil mode anyways.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
   :n ")" 'org-next-visible-heading
   :n "(" 'org-previous-visible-heading
   :leader "g u" 'outline-up-heading)               ;; Go Up in hierarchy
#+END_SRC

By default ~g u~ is bound to ~evil-downcase~.

*** archiving

When I archive something it is usually also done. By default however archiving doesn't change the todo-state.
So let's have a command that does both.

#+BEGIN_SRC emacs-lisp
(defun ab/mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(map! :map org-mode-map :leader "o d" 'ab/mark-done-and-archive)
#+END_SRC

** org capture

Keep everything out of your head! Has to be as convenient as possible.

*** config

Always start in insert mode when capturing.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-capture-mode-hook 'evil-insert-state))
#+END_SRC

When refiling I want to be able to refile also to a subheading.

#+BEGIN_SRC emacs-lisp
;; (setq org-refile-targets '((nil :maxlevel . 6)
;;                            (org-agenda-files :maxlevel . 6)))
;; (setq org-completion-use-ido t)
;; (setq org-outline-path-complete-in-steps nil) ;; has to be nil for ido to work
;; (setq org-refile-use-outline-path 'file)
#+END_SRC

This seems to work in doom out of the box.

*** templates

Templates for capturing. Also, ~%a~ expands to a link to the file (and position)
from which =org-capture= was called. I think =%i= is active region. Another nice
feature is ~%^{Name}~ prompts for name. This probably makes sense for titles or
something because I tend to put too much next to the asterics and too little
text underneath..

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-capture-templates
        '(("l" "todo with Link" entry
           (file+headline org-index-file "Inbox")
           "*** TODO %?\n  %i\n  See: %a\n")

          ("n" "Note"  entry
           (file+headline org-index-file "Inbox")
           "*** %?\n\n")

          ("t" "Todo" entry
           (file+headline org-index-file "Inbox")
           "*** TODO %?\n"))))
#+END_SRC

*** capture anywhere

Call org-capture from anywhere (system wide). Code taken from [[https://www.reddit.com/r/emacs/comments/74gkeq/system_wide_org_capture/][reddit.]]

#+BEGIN_SRC emacs-lisp
(after! org
  (defadvice org-switch-to-buffer-other-window
      (after supress-window-splitting activate)
    "Delete the extra window if we're in a capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-other-windows)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defun activate-capture-frame ()
    "run org-capture in capture frame"
    (select-frame-by-name "capture")
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (org-capture)))
#+END_SRC

The above code, together with the follow shell command does the job.

# #+BEGIN_SRC shell :eval no
# emacsclient -c -F '(quote (name . "capture"))' -e '(activate-capture-frame)'
# #+END_SRC

For this to work the emacs server hast to be running.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

The other option would be to start emacs as a daemon. can even be started with systemd, see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html][link]]

** appearance

Everything that has to do with how stuff looks / is displayed.

*** "headings"

By default the only difference between org levels is a slightly different symbol (when using =org-bullets=).
Different font sizes make much more sense.

Also, in nord theme all headings seem to have the same color...

#+BEGIN_SRC emacs-lisp
(after! org
  (custom-set-faces
   '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
   '(org-level-2 ((t (:inherit outline-2 :height 1.3))))
   '(org-level-3 ((t (:inherit outline-3 :height 1.2))))
   '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
   '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
   ))
#+END_SRC

By default orgmode displays ellipsis for collapsed bullets. Here's a custom symbol indicating collapsed bullets.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-ellipsis " ..."))
#+END_SRC

*** prettify entities

Org can pretty display things like latex symbols. Indices are even nicer than in AucTex as the underscores are removed.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-pretty-entities 1))
#+END_SRC

** opening pdfs

I want pdfs to be opened in an external pdf viewer.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-mode-hook
            '(lambda ()
               (delete '("\\.pdf\\'" . default) org-file-apps)
               (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s")))))
#+END_SRC

** org-notify

I want notifications for scheduled headlines. Unfortunately ~org-alert~ only has the capability to notify every N minutes and doesn't consider the time an item is scheduled for

This package sends a notification x minutes before schedule and even allows for
multiple notifications per TODO.

#+BEGIN_SRC emacs-lisp
(use-package! org-wild-notifier
  :defer t
  :init
  (add-hook 'doom-after-init-modules-hook #'org-wild-notifier-mode t)
  :config
  (setq org-wild-notifier-alert-time 15
        ;; use dunst for system wide notifications
        alert-default-style 'libnotify))
#+END_SRC

* LaTeX
** general

#+BEGIN_SRC emacs-lisp
(after! latex
  (setq tex-fontify-script t
        TeX-save-query nil
        ;; don't show ^ or _ for scripts
        font-latex-fontify-script 'invisible)
  ;; (add-to-list 'TeX-command-list '("LatexMk" "latexmk -pdflatex='pdflatex -file-line-error -synctex=1' -pdf %t" TeX-run-TeX nil))

  ;; use Zathura as pdf viewer
  (setq TeX-view-program-selection '((output-pdf "Zathura"))
        TeX-source-correlate-start-server t))
#+END_SRC

** keybindings

#+BEGIN_SRC emacs-lisp
(map! :map LaTeX-mode-map
      :leader
      "m l" 'TeX-command-run-all
      "m v" 'Tex-view
      "m f" 'Tex-fold-env
      "m n" 'LaTeX-narrow-to-environment)
#+END_SRC

* snippets

Snippets are everything! still need to figure out how to incorporate snippets into autocompletion (the way deoplete and Ultisnips did it for vim).

#+BEGIN_SRC emacs-lisp
(use-package! yasnippet
  :config
  (setq yas-snippet-dirs '("~/.doom.d/snippets"))
  (map! :i "C-e" 'yas-expand)
  (map!
   :leader "s n" 'yas-new-snippet              ;; Snippet New
   :leader "s g" 'yas-visit-snippet-file))      ;; Snippet Go
#+END_SRC

see [[https://stackoverflow.com/questions/14066526/unset-tab-binding-for-yasnippet][stackoverflow]] for some helpful answers.
* syntax checking

#+BEGIN_SRC emacs-lisp
;; (use-package! flycheck
;;   :config
;;   (global-flycheck-mode)
;;   ;; (flycheck-display-errors-delay .3)
;;   (setq-default flycheck-disabled-checkers '(tex-chktex)))
#+END_SRC

There is a bug in ~chk-tex~, see [[https://github.com/flycheck/flycheck/issues/1214][issue]]. They also describe possible workarounds.

Fixing would be nice too, but apparently this is open, cf. [[https://github.com/flycheck/flycheck/issues/530][issue]].

* git

#+BEGIN_SRC emacs-lisp
(after! magit
  :config
  (use-package evil-magit)
  ;; This library makes it possible to reliably use the Emacsclient as the $EDITOR of child processes.
  (use-package with-editor))

(map! :leader "g g" 'magit-status)
#+END_SRC

* R

#+BEGIN_SRC emacs-lisp
;; (after! ess)
;; (use-package ess-smart-underscore
;;   :after ess)
#+END_SRC
* auto completion

I used to think =company= is slow, but I just had to turn the ~idle-delay~ down...

#+BEGIN_SRC emacs-lisp
(after! company
  :init
  (setq company-dabbrev-ignore-case t
        company-idle-delay 0.1
        company-tooltip-limit 8
        company-tooltip-minimum-width 40
        company-minimum-prefix-length 2)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  ;; Add yasnippet support for all company backends
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")
  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

  (map! :i "C-n" 'company-complete)) ;; doesn't work

(map! (:when (featurep! :completion company)
        :i "C-n"      #'+company/complete
        :i "C-SPC"    #'+company/complete))
#+END_SRC

The code chunk in the middle which makes yasnippet work with company is taken from [[https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names][stackexchange]]. How can people live without this?? Also for some reason it has to be inside the entire thing even if company is not defered (no idea why).

* spell checking

As the name suggests. According to [[https://fasciism.com/2017/01/16/spellchecking/][this site]] Aspell is unmaintained and Hunspell is the way to go.

Default binding: ~z =~ for suggestions on how to correct the word.

#+BEGIN_SRC emacs-lisp
(after! flyspell
  :config
  (map! :leader "s c" 'flyspell-mode)      ;; toggle spell checking
  (map! :n "z=" 'ispell-word)

  (setq ispell-program-name "hunspell"
        ispell-silently-savep t            ;; save persal dictionary without asking
        ispell-local-dictionary "en_US"
        ;; ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
        ispell-list-command "--list"
        ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "['‘’]"
                                         t ; Many other characters
                                         ("-d" "en_US") nil utf-8))))
#+END_SRC

vim has a command for directly adding new words to dictionary. I want this.

#+BEGIN_SRC emacs-lisp
(defun ab/save-word ()
  (interactive)
  (let ((current-location (point))
        (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))

(map! :n "z g" 'ab/save-word)
#+END_SRC

* fuzzy matching

The ~counsel~ package installs all three of them. ~Swiper~ is just the fancy
search. ~Ivy~ does the narrowing. ~counsel~ adds options to ~Ivy~

#+BEGIN_SRC emacs-lisp
(use-package! counsel
  :config
  (ivy-mode 1)
  ;; Virtual buffers correspond to bookmarks and recent files list
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  (global-set-key "\C-s" 'swiper)

  (map! :leader "f f" 'counsel-find-file)
  ;; make projectile use ivy as completion system
  ;; (setq projectile-completion-system 'ivy)

  ;; Deletes current input, resets the candidates list to the currently restricted matches.
  (define-key minibuffer-local-map (kbd "S-SPC") 'ivy-restrict-to-matches))
#+END_SRC
* auto closing of parenthesis

Smart treatment of parenthesis, like auto closing or auto deletion of the matching one.

#+BEGIN_SRC emacs-lisp
(use-package! smartparens
  :config
  (sp-local-pair 'org-mode "$" "$")
  (sp-local-pair 'latex-mode "$" "$")   ;; omg, I want this so badly
  (sp-local-pair 'latex-mode "\\langle" "\\rangle" :trigger "\\lan")
  (sp-local-pair 'latex-mode "\\lVert" "\\rVert" :trigger "\\lVe")

  (sp-local-pair 'latex-mode "\\left(" "\\right)" :trigger "\\l(")
  (sp-local-pair 'latex-mode "\\left[" "\\right]" :trigger "\\l[")
  (sp-local-pair 'latex-mode "\\left\\{" "\\right\\}" :trigger "\\l{")
  (sp-local-pair 'latex-mode "\\left\\langle" "\\right\\rangle" :trigger "\\left\\la(")

  (smartparens-global-mode 1)) ;; I always want this
#+END_SRC
* mail

finally I found a config using offlineimap.

#+BEGIN_SRC emacs-lisp
;; (after! mu4e
;;   (setq +mu4e-backend 'offlineimap)
;;   ;; (set-email-account! "EduPolitech"
;;   ;;   `((mu4e-sent-folder       . "/edu-politech/Sent Mail")
;;   ;;     (mu4e-drafts-folder     . "/edu-politech/Drafts")
;;   ;;     (mu4e-trash-folder      . "/edu-politech/Trash")
;;   ;;     (mu4e-refile-folder     . "/edu-politech/All Mail")
;;   ;;     (smtpmail-smtp-user     . ,(password-store-get "mail/edu-politech"))
;;   ;;     (user-mail-address      . ,(password-store-get "mail/edu-politech"))
;;   ;;     (mu4e-compose-signature . "---\nEdu Politech"))
;;   ;;   t)
;;   (set-email-account! "MainMail"
;;     `((mu4e-sent-folder       . "~/.mail/uniwien/Sent")
;;       (mu4e-drafts-folder     . "~/.mail/uniwien/Drafts")
;;       (mu4e-trash-folder      . "~/.mail/uniwien/Trash")
;;       (mu4e-refile-folder     . "/All Mail")
;;       (smtpmail-smtp-user     . ,(auth-source-pass-get "user" "mail/mainmail"))
;;       (user-mail-address      . ,(auth-source-pass-get "user" "mail/mainmail"))
;;       (mu4e-compose-signature . "---\nMain Mail")))
;;   (set-email-account! "Paradox"
;;     `((mu4e-sent-folder       . "/paradox/Sent Mail")
;;       (mu4e-drafts-folder     . "/paradox/Drafts")
;;       (mu4e-trash-folder      . "/paradox/Trash")
;;       (mu4e-refile-folder     . "/paradox/All Mail")
;;       (smtpmail-smtp-user     . ,(auth-source-pass-get "user" "mail/paradox"))
;;       (user-mail-address      . ,(auth-source-pass-get "user" "mail/paradox"))
;;       (mu4e-compose-signature . "---\nParadox"))
;;     t))

;; (add-to-list 'load-path "/usr/share/emacs/site-lisp")

(after! mu4e
  (setq +mu4e-backend 'offlineimap)
  (setq mu4e-maildir "~/.mail")

;; Each path is relative to `+mu4e-mu4e-mail-path', which is ~/.mail by default
(set-email-account! "uniwien"
  '((mu4e-sent-folder       . "/uniwien/INBOX.Sent/")
    (mu4e-drafts-folder     . "/uniwien/INBOX.Drafts")
    (mu4e-trash-folder      . "/uniwien/INBOX.Trash")
    (mu4e-refile-folder     . "/uniwien/INBOX.Archive")
    (smtpmail-smtp-user     . "axel.boehm@univie.ac.at")
    (user-mail-address      . "axel.boehm@univie.ac.at")
    (mu4e-compose-signature . "---\nAxel Boehm"))
  t)

  ;; use mu4e for e-mail in emacs
  (setq mail-user-agent 'mu4e-user-agent)
  ;; (Setq mu4e-sent-messages-behavior 'delete)

  ;; allow for updating mail using 'U' in the main view:
  ;; (setq mu4e-get-mail-command "offlineimap") )
  )
#+END_SRC
